using Basics.Interfaces;

namespace Basics.Classes;

public class Address(string country, string city, string street, ushort buildingNumber) : IPrintable
{
    public string Country { get; set; } = country;
    public string City { get; set; } = city;
    public string Street { get; set; } = street;
    public ushort BuildingNumber { get; set; } = buildingNumber;
    public void PrintInfo()
    {
        Console.WriteLine($"{Country} {City} {Street} {BuildingNumber}");
    }
}
using Basics.Interfaces;
using System.Text.Json.Serialization;
namespace Basics.Classes;

public class Book : IReadable, IPrintable
{
    public string Title { get; set; }
    public string Author { get; set; }
    public ushort? Year { get; set; }
    [JsonConstructor]
    public Book(string title, string author, ushort? year)
    {
        Title = title;
        Author = author;
        Year = year;
    }
    public Book(string title) : this(title, "Unknown", null) { }
    public void ReadCover()
    {
        Console.WriteLine($"{Title}, {Author}, {Year}");
    }
    public void PrintInfo() => ReadCover();
}

namespace Basics.Classes;
public class Circle(double radius) : Shape("Circle")
{
    public double Radius { get; set; } = radius;
    public override double GetArea()
    {
        return Math.PI * Math.Pow(Radius, 2);
    }
}

namespace Basics.Classes;
public class Customer(string name, string email, Address address) : User(name, email)
{
    public Address Address { get; set; } = address;
    public override void PrintInfo()
    {
        base.PrintInfo();
        Address.PrintInfo();
    }
}

using Basics.Exceptions;
using Basics.Interfaces;
namespace Basics.Classes;
public class Library : ILibrarySearchable, IPrintable, ILibraryOperatable
{
    public Dictionary<string, List<Book>> Books { get; set; } = []; //Author: List<Book>
    public Library() { }
    public Library(Dictionary<string, List<Book>> books) => Books = books;
    public Library(List<Book> books) : this(
        books
            .GroupBy(b => b.Author)
            .ToDictionary(g => g.Key, g => g.ToList())
    )
    { }
    public void AddBook(Book book)
    {
        if (Books.TryGetValue(book.Author, out List<Book>? value))
        {
            value.Add(book);
        }
        else
        {
            Books.Add(book.Author, [book]);
        }
    }
    public void RemoveBook(string author, string title)
    {
        Books[author].RemoveAll(b => b.Title != title);
    }
    public void RemoveAllBooksByAuthor(string author)
    {
        if (Books.TryGetValue(author, out List<Book>? books))
        {
            Books.Remove(author);
        }
        else
        {
            throw new AuthorNotFoundException($"Books with author \"{author}\" not found");
        }
    }
    public void RemoveAllBooksWithTitle(string title)
    {
        var containFlag = false;
        foreach (var pair in Books)
        {
            if (pair.Value.Any(b => b.Title == title))
            {
                pair.Value.RemoveAll(b => b.Title == title);
                containFlag = true;
            }
        }
        if (!containFlag)
        {
            throw new TitleNotFoundException($"Books with title \"{title}\" not found");
        }
    }
    public IEnumerable<Book> FindAllBooksByTitle(string title)
    {
        return Books
            .Values
            .SelectMany(list => list)
            .Where(b => b.Title == title);
    }
    public IEnumerable<Book> FindAllBooksByAuthor(string author)
    {
        return Books[author];
    }
    public IEnumerable<Book> FindAllBooksByYear(ushort? year)
    {
        return Books
            .Values
            .SelectMany(list => list)
            .Where(b => b.Year == year);
    }
    public Book? FindBook(string title, string author, ushort? year)
    {
        return Books[author]
            .FirstOrDefault(b =>
                b.Title == title &&
                b.Year == year
            );
    }
    public List<Book> Filter(Func<Book, bool> filter)
    {
        return Books.Values.SelectMany(list => list).Where(filter).ToList();
    }
    public void PrintInfo()
    {
        foreach (var pair in Books)
        {
            Console.WriteLine(pair.Key);
            foreach (var book in pair.Value)
            {
                Console.WriteLine($" - \"{book.Title}\", {book.Year}");
            }
        }
    }
    public List<Book> FilterParallel(Func<Book, bool> filter)
    {
        return Books
            .Values
            .AsParallel()
            .SelectMany(list => list)
            .Where(filter)
            .ToList();
    }
}

using Basics.Interfaces;
using System.Globalization;

namespace Basics.Classes;

public class Order(Customer customer, Dictionary<Product, ushort>? products, DateOnly date) : IPrintable, IOrderExportable, IOrderOperatable
{
    public Order(Customer customer, List<Product> products, DateOnly date)
    : this(customer,
        products.GroupBy(p => p).ToDictionary(g => g.Key, g => (ushort)g.Count()),
        date
    )
    { }
    public Customer Customer { get; set; } = customer;
    public Dictionary<Product, ushort> Products { get; set; } = products ?? [];
    public DateOnly Date { get; set; } = date;
    public decimal GetTotalPrice() => Products.Sum(pair => pair.Key.Price * pair.Value);
    public void AddProduct(Product product)
    {
        if (Products.TryGetValue(product, out ushort value))
        {
            Products[product] = ++value;
        }
        else
        {
            Products.Add(product, 0);
        }
    }
    public int GetUniqueCount() => Products.Keys.Count;
    public void PrintInfo(TextWriter writer)
    {
        CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
        writer.WriteLine($"Customer: {Customer.Name}");
        foreach (var product in Products)
        {
            var total_price = product.Key.Price * product.Value;
            writer.WriteLine(
                $" - {product.Key.Name} x {product.Value}: {total_price}$"
            );
        }
        writer.WriteLine($"Total: {GetTotalPrice()}$");
    }
    public void PrintInfo() => PrintInfo(Console.Out);
    public void ExportToText(string path = "../../../Data/OrderWrite/Order.txt")
    {
        using var sw = new StreamWriter(path);
        PrintInfo(sw);
    }
    public async Task PrintInfoAsync(TextWriter writer)
    {
        CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
        await writer.WriteLineAsync($"Customer: {Customer.Name}");
        foreach (var product in Products)
        {
            var total_price = product.Key.Price * product.Value;
            await writer.WriteLineAsync(
                $" - {product.Key.Name} x {product.Value}: {total_price}$"
            );
        }
        await writer.WriteLineAsync($"Total: {GetTotalPrice()}$");
    }
    public async Task PrintInfoAsync() => await PrintInfoAsync(Console.Out);
    public async Task ExportToTextAsync(string path = "../../../Data/OrderWrite/Order.txt")
    {
        await using var sw = new StreamWriter(path);
        await PrintInfoAsync(sw);
    }
}
using Basics.Interfaces;

namespace Basics.Classes;
public class Person(string name, ushort age) : IPresentable, IPrintable
{
    public string Name { get; set; } = name;
    public ushort Age { get; set; } = age;
    public virtual void Introduce()
    {
        Console.WriteLine($"My name is {Name}, I am {Age} years old");
    }
    public void PrintInfo() => Introduce();
}

using Basics.Interfaces;

namespace Basics.Classes;
public readonly record struct Product(string name, decimal price) : IPurchasable, IOrderable, IPrintable
{
    public string Name { get; } = name;
    public decimal Price { get; } = price;
    public void PrintInfo()
    {
        Console.WriteLine($"Name: {Name}, Price: {Price}");
    }
}
namespace Basics.Classes;
public class Rectangle(double width, double height) : Shape("Rectangle")
{
    public double Width { get; set; } = width;
    public double Height { get; set; } = height;
    public override double GetArea()
    {
        return Width * Height;
    }
}

using Basics.Interfaces;

namespace Basics.Classes;
public abstract class Shape(string name) : IAreaComputable, IPrintable
{
    public string Name { get; set; } = name;
    public abstract double GetArea();
    public void PrintInfo()
    {
        Console.WriteLine($"{Name}: {GetArea()}");
    }
}

using System.Collections.Concurrent;
using Basics.Interfaces;
namespace Basics.Classes;
public class Store(List<Product>? products, ConcurrentQueue<Order>? orders) : IStore, IPrintable, IStoreSearchable
{
    public List<Product> Catalogue { get; set; } = products ?? [];
    public ConcurrentQueue<Order> Orders { get; set; } = orders ?? [];
    public void AddProduct(Product product)
    {
        Catalogue.Add(product);
    }
    public void PlaceOrder(Order order)
    {
        Orders.Enqueue(order);
    }
    public void PlaceOrders(List<Order> orders)
    {
        orders.ForEach(o => PlaceOrder(o));
    }
    public Order ProcessOrder()
    {
        if (Orders.TryDequeue(out var value))
        {
            return value;
        }
        else
        {
            throw new ArgumentNullException();
        }
    }
    public IEnumerable<Order> GetOrdersByCustomer(string customerName)
    {
        return Orders.Where(o => o.Customer.Name == customerName);
    }
    public IEnumerable<Product> GetProductsCheaperThan(decimal maxPrice)
    {
        return Catalogue.Where(c => c.Price <= maxPrice);
    }
    public void PrintInfo()
    {
        foreach (var product in Catalogue)
        {
            product.PrintInfo();
        }
        foreach (var order in Orders)
        {
            order.PrintInfo();
        }
    }
    public void PrintAllOrders()
    {
        Orders.ToList().ForEach(o => o.PrintInfo());
    }
}
namespace Basics.Classes;
public class Student(string group, string name, ushort age) : Person(name, age)
{
    public string Group { get; set; } = group;
    public override void Introduce()
    {
        Console.Write($"I am a student of a group {Group}, ");
        base.Introduce();
    }
}

namespace Basics.Classes;
public class Teacher(string subject, string name, ushort age) : Person(name, age)
{
    public string Subject { get; set; } = subject;
    public override void Introduce()
    {
        Console.Write($"I am a {Subject} teacher, ");
        base.Introduce();
    }
}
using Basics.Interfaces;

namespace Basics.Classes;

public class User(string name, string email) : IUserInfo, IPrintable
{
    public string Name { get; set; } = name;
    public string Email { get; set; } = email;
    public virtual void PrintInfo()
    {
        Console.WriteLine($"Name: {Name}, Email: {Email}");
    }
}
namespace Basics.Exceptions;

public class AuthorNotFoundException : Exception
{
    public AuthorNotFoundException() { }
    public AuthorNotFoundException(string message) : base(message) { }
    public AuthorNotFoundException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.Exceptions;

public class LibraryLoadingException : Exception
{
    public LibraryLoadingException() { }
    public LibraryLoadingException(string message) : base(message) { }
    public LibraryLoadingException(string message, Exception innerException) : base(message, innerException) { }
}
namespace Basics.Exceptions;

public class LibrarySavingException : Exception
{
    public LibrarySavingException() { }
    public LibrarySavingException(string message) : base(message) { }
    public LibrarySavingException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.Exceptions;

public class TitleNotFoundException : Exception
{
    public TitleNotFoundException() { }
    public TitleNotFoundException(string message) : base(message) { }
    public TitleNotFoundException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.Interfaces;
public interface IAreaComputable
{
    public double GetArea();
}
namespace Basics.Interfaces;
public interface IUserInfo
{
    public string Name { get; set; }
    public string Email { get; set; }
}
using Basics.Classes;

namespace Basics.Interfaces;
public interface ILibraryOperatable
{
    public void AddBook(Book book);
    public void RemoveBook(string author, string title);
    public void RemoveAllBooksByAuthor(string author);
    public void RemoveAllBooksWithTitle(string title);
}

using Basics.Classes;

namespace Basics.Interfaces;
public interface ILibrarySearchable
{
    IEnumerable<Book> FindAllBooksByTitle(string title);
    IEnumerable<Book> FindAllBooksByAuthor(string author);
    IEnumerable<Book> FindAllBooksByYear(ushort? year);
    Book? FindBook(string title, string author, ushort? year);
}

namespace Basics.Interfaces;

public interface IOrderable { }
namespace Basics.Interfaces;

public interface IOrderExportable
{
    public void ExportToText(string path);
}

using Basics.Classes;

namespace Basics.Interfaces;

public interface IOrderOperatable
{
    public void AddProduct(Product product);
}
namespace Basics.Interfaces;
public interface IPresentable
{
    public void Introduce();
}
namespace Basics.Interfaces;
public interface IPrintable
{
    public void PrintInfo();
}
namespace Basics.Interfaces;

public interface IPurchasable
{
    public string Name { get; }
    public decimal Price { get; }
}

namespace Basics.Interfaces;
public interface IReadable
{
    public void ReadCover();
}

using Basics.Classes;

namespace Basics.Interfaces;

public interface IStore
{
    public void AddProduct(Product product);
    public void PlaceOrder(Order order);
    public Order ProcessOrder();
}
using Basics.Classes;

namespace Basics.Interfaces;
public interface IStoreSearchable
{
    public IEnumerable<Order> GetOrdersByCustomer(string customerId);
    public IEnumerable<Product> GetProductsCheaperThan(decimal maxPrice);
}
{
  "format": 1,
  "restore": {
    "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj": {}
  },
  "projects": {
    "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj": {
      "version": "1.0.0",
      "restore": {
        "projectUniqueName": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj",
        "projectName": "Basics",
        "projectPath": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj",
        "packagesPath": "C:\\Users\\Admin\\.nuget\\packages\\",
        "outputPath": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\obj\\",
        "projectStyle": "PackageReference",
        "fallbackFolders": [
          "F:\\Games\\Visual Studio\\Installed\\Components\\NuGetPackages"
        ],
        "configFilePaths": [
          "C:\\Users\\Admin\\AppData\\Roaming\\NuGet\\NuGet.Config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
          "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
        ],
        "originalTargetFrameworks": [
          "net8.0"
        ],
        "sources": {
          "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
          "C:\\Program Files\\dotnet\\library-packs": {},
          "https://api.nuget.org/v3/index.json": {}
        },
        "frameworks": {
          "net8.0": {
            "targetAlias": "net8.0",
            "projectReferences": {}
          }
        },
        "warningProperties": {
          "warnAsError": [
            "NU1605"
          ]
        },
        "restoreAuditProperties": {
          "enableAudit": "true",
          "auditLevel": "low",
          "auditMode": "direct"
        }
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "dependencies": {
            "Newtonsoft.Json": {
              "target": "Package",
              "version": "[13.0.3, )"
            }
          },
          "imports": [
            "net461",
            "net462",
            "net47",
            "net471",
            "net472",
            "net48",
            "net481"
          ],
          "assetTargetFallback": true,
          "warn": true,
          "frameworkReferences": {
            "Microsoft.NETCore.App": {
              "privateAssets": "all"
            }
          },
          "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\8.0.200/PortableRuntimeIdentifierGraph.json"
        }
      }
    }
  }
}
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <RestoreSuccess Condition=" '$(RestoreSuccess)' == '' ">True</RestoreSuccess>
    <RestoreTool Condition=" '$(RestoreTool)' == '' ">NuGet</RestoreTool>
    <ProjectAssetsFile Condition=" '$(ProjectAssetsFile)' == '' ">$(MSBuildThisFileDirectory)project.assets.json</ProjectAssetsFile>
    <NuGetPackageRoot Condition=" '$(NuGetPackageRoot)' == '' ">$(UserProfile)\.nuget\packages\</NuGetPackageRoot>
    <NuGetPackageFolders Condition=" '$(NuGetPackageFolders)' == '' ">C:\Users\Admin\.nuget\packages\;F:\Games\Visual Studio\Installed\Components\NuGetPackages</NuGetPackageFolders>
    <NuGetProjectStyle Condition=" '$(NuGetProjectStyle)' == '' ">PackageReference</NuGetProjectStyle>
    <NuGetToolVersion Condition=" '$(NuGetToolVersion)' == '' ">6.9.1</NuGetToolVersion>
  </PropertyGroup>
  <ItemGroup Condition=" '$(ExcludeRestorePackageImports)' != 'true' ">
    <SourceRoot Include="C:\Users\Admin\.nuget\packages\" />
    <SourceRoot Include="F:\Games\Visual Studio\Installed\Components\NuGetPackages\" />
  </ItemGroup>
</Project>
<?xml version="1.0" encoding="utf-8" standalone="no"?>
<Project ToolsVersion="14.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" />
{
  "version": 3,
  "targets": {
    "net8.0": {
      "Newtonsoft.Json/13.0.3": {
        "type": "package",
        "compile": {
          "lib/net6.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        },
        "runtime": {
          "lib/net6.0/Newtonsoft.Json.dll": {
            "related": ".xml"
          }
        }
      }
    }
  },
  "libraries": {
    "Newtonsoft.Json/13.0.3": {
      "sha512": "HrC5BXdl00IP9zeV+0Z848QWPAoCr9P3bDEZguI+gkLcBKAOxix/tLEAAHC+UvDNPv4a2d18lOReHMOagPa+zQ==",
      "type": "package",
      "path": "newtonsoft.json/13.0.3",
      "files": [
        ".nupkg.metadata",
        ".signature.p7s",
        "LICENSE.md",
        "README.md",
        "lib/net20/Newtonsoft.Json.dll",
        "lib/net20/Newtonsoft.Json.xml",
        "lib/net35/Newtonsoft.Json.dll",
        "lib/net35/Newtonsoft.Json.xml",
        "lib/net40/Newtonsoft.Json.dll",
        "lib/net40/Newtonsoft.Json.xml",
        "lib/net45/Newtonsoft.Json.dll",
        "lib/net45/Newtonsoft.Json.xml",
        "lib/net6.0/Newtonsoft.Json.dll",
        "lib/net6.0/Newtonsoft.Json.xml",
        "lib/netstandard1.0/Newtonsoft.Json.dll",
        "lib/netstandard1.0/Newtonsoft.Json.xml",
        "lib/netstandard1.3/Newtonsoft.Json.dll",
        "lib/netstandard1.3/Newtonsoft.Json.xml",
        "lib/netstandard2.0/Newtonsoft.Json.dll",
        "lib/netstandard2.0/Newtonsoft.Json.xml",
        "newtonsoft.json.13.0.3.nupkg.sha512",
        "newtonsoft.json.nuspec",
        "packageIcon.png"
      ]
    }
  },
  "projectFileDependencyGroups": {
    "net8.0": [
      "Newtonsoft.Json >= 13.0.3"
    ]
  },
  "packageFolders": {
    "C:\\Users\\Admin\\.nuget\\packages\\": {},
    "F:\\Games\\Visual Studio\\Installed\\Components\\NuGetPackages": {}
  },
  "project": {
    "version": "1.0.0",
    "restore": {
      "projectUniqueName": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj",
      "projectName": "Basics",
      "projectPath": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj",
      "packagesPath": "C:\\Users\\Admin\\.nuget\\packages\\",
      "outputPath": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\obj\\",
      "projectStyle": "PackageReference",
      "fallbackFolders": [
        "F:\\Games\\Visual Studio\\Installed\\Components\\NuGetPackages"
      ],
      "configFilePaths": [
        "C:\\Users\\Admin\\AppData\\Roaming\\NuGet\\NuGet.Config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.FallbackLocation.config",
        "C:\\Program Files (x86)\\NuGet\\Config\\Microsoft.VisualStudio.Offline.config"
      ],
      "originalTargetFrameworks": [
        "net8.0"
      ],
      "sources": {
        "C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\": {},
        "C:\\Program Files\\dotnet\\library-packs": {},
        "https://api.nuget.org/v3/index.json": {}
      },
      "frameworks": {
        "net8.0": {
          "targetAlias": "net8.0",
          "projectReferences": {}
        }
      },
      "warningProperties": {
        "warnAsError": [
          "NU1605"
        ]
      },
      "restoreAuditProperties": {
        "enableAudit": "true",
        "auditLevel": "low",
        "auditMode": "direct"
      }
    },
    "frameworks": {
      "net8.0": {
        "targetAlias": "net8.0",
        "dependencies": {
          "Newtonsoft.Json": {
            "target": "Package",
            "version": "[13.0.3, )"
          }
        },
        "imports": [
          "net461",
          "net462",
          "net47",
          "net471",
          "net472",
          "net48",
          "net481"
        ],
        "assetTargetFallback": true,
        "warn": true,
        "frameworkReferences": {
          "Microsoft.NETCore.App": {
            "privateAssets": "all"
          }
        },
        "runtimeIdentifierGraphPath": "C:\\Program Files\\dotnet\\sdk\\8.0.200/PortableRuntimeIdentifierGraph.json"
      }
    }
  }
}
{
  "version": 2,
  "dgSpecHash": "62XkJDXETErg+GyzJPOJnfVu7q2IoUembFDGYuHsffkQLUNZYTNMkmRDhPWd8XMXhOBFyMXl/jNZSNtfOtlUsw==",
  "success": true,
  "projectFilePath": "F:\\Programmes\\Github\\Reps\\Training-DotNet\\Training\\Basics\\Basics.csproj",
  "expectedPackageFiles": [
    "C:\\Users\\Admin\\.nuget\\packages\\newtonsoft.json\\13.0.3\\newtonsoft.json.13.0.3.nupkg.sha512"
  ],
  "logs": []
}
using System.Text.Json;
using Basics.Exceptions;
using Basics.Classes;
namespace Basics.Services;
public static class LibraryHandler
{
    public static void SaveToFile(this Library library, string path = "../../../Data/LibraryWrite/Library.json")
    {
        try
        {
            using var fs = File.Create(path);
            JsonSerializer.SerializeAsync(fs, library);
        }
        catch (Exception e)
        {
            throw new LibrarySavingException(e.Message);
        }
    }
    public static async Task SaveToFileAsync(this Library library, string path = "../../../Data/LibraryWrite/Library.json")
    {
        try
        {
            await using var fs = File.Create(path);
            await JsonSerializer.SerializeAsync(fs, library);
        }
        catch (Exception e)
        {
            throw new LibrarySavingException(e.Message);
        }
    }
    public static Library? LoadFromFile(string path = "../../../Data/LibraryRead/Library.json")
    {
        try
        {
            using var fs = File.OpenRead(path);
            return JsonSerializer.Deserialize<Library>(fs);
        }
        catch (Exception e)
        {
            throw new LibraryLoadingException(e.Message);
        }
    }
    public static async Task<Library?> LoadFromFileAsync(string path = "../../../Data/LibraryRead/Library.json")
    {
        try
        {
            await using var fs = File.OpenRead(path);
            return await JsonSerializer.DeserializeAsync<Library>(fs);
        }
        catch (Exception e)
        {
            throw new LibraryLoadingException(e.Message);
        }
    }
    public static async Task<List<Library>> LoadAllLibrariesAsync(List<string> paths)
    {
        var libraryTasks = paths.Select(LoadFromFileAsync);
        var libraries = await Task.WhenAll(libraryTasks);
        return libraries.Where(lib => lib is not null).ToList()!;
    }
}
using Basics.Interfaces;

namespace Basics.Services;

public static class PersonHandler
{
    public static void IntroduceAll(this List<IPresentable> presentables)
    {
        foreach (var presentable in presentables)
        {
            presentable.Introduce();
        }
    }
}
using Basics.Interfaces;

namespace Basics.Services;
public static class PrintHandler
{
    public delegate void PrintDelegate(IPrintable printable);
    public static void PrintAll(this List<IPrintable> printables, PrintDelegate printer)
    {
        foreach (var printable in printables)
        {
            printer(printable);
        }
    }
}
using System.Collections.Concurrent;
using Basics.Classes;

namespace Basics.Services;
public static class ProductHandler
{
    public static List<Product> GenerateRandomProducts(int productsQuantity)
    {
        var bag = new ConcurrentBag<Product>();
        var tasks = new List<Task>();

        var threadCount = Environment.ProcessorCount;
        var prodPerThread = productsQuantity / threadCount;
        var prodRemainder = productsQuantity % threadCount;

        for (var i = 0; i < threadCount; i++)
        {
            var threadIndex = i;
            tasks.Add(Task.Run(() =>
            {
                var rnd = Random.Shared;
                var prodsToCreate = prodPerThread + (threadIndex < prodRemainder ? 1 : 0);
                for (var j = 0; j < prodsToCreate; j++)
                {
                    var prodName = $"Name_{threadIndex}_{j}";
                    var prodPrice = 10 * threadIndex + j;
                    var p = new Product(prodName, prodPrice);
                    bag.Add(p);
                }
            }));
        }

        Task.WaitAll([.. tasks]);
        return [.. bag];
    }
}

using Basics.Classes;

namespace Basics.Services;

public static class ShapeHandler
{
    public static void PrintAllAreas(List<Shape> shapes)
    {
        foreach (var shape in shapes)
        {
            Console.WriteLine(shape.GetArea());
        }
    }
}
using Basics.Classes;

namespace Basics.Services;
public static class StoreHandler
{
    public static async Task ExportAllOrdersAsync(Store store, string folderPath)
    {
        var quantity = store.Orders.Count;
        var taskList = store.Orders.Select((o, i) =>
        {
            var path = Path.Combine(folderPath, $"Order_{i + 1}");
            return o.ExportToTextAsync(path);
        });
        await Task.WhenAll(taskList);
    }
}

namespace Basics.Utilities;
public static class MergeFiles
{
    public static void Merge(this List<string> directoryPaths, string resultPath = "../../../Utilities/Result/Merged.txt")
    {
        using var sw = new StreamWriter(resultPath);
        foreach (var directoryPath in directoryPaths)
        {
            foreach (var file in Directory.GetFiles(directoryPath))
            {
                using var sr = new StreamReader(file);
                sw.WriteLine(sr.ReadToEnd());
            }
        }
    }
}
