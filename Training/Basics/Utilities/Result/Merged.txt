using Basics.OOP.Interfaces;

namespace Basics.OOP.Classes;

public class Address(string country, string city, string street, ushort buildingNumber) : IPrintable
{
    public string Country { get; set; } = country;
    public string City { get; set; } = city;
    public string Street { get; set; } = street;
    public ushort BuildingNumber { get; set; } = buildingNumber;
    public void PrintInfo()
    {
        Console.WriteLine($"{Country} {City} {Street} {BuildingNumber}");
    }
}
using Basics.OOP.Interfaces;
using System.Text.Json.Serialization;
namespace Basics.OOP.Classes;

public class Book : IReadable, IPrintable
{
    public string Title { get; set; }
    public string Author { get; set; } 
    public ushort? Year { get; set; }
    [JsonConstructor]
    public Book(string title, string author, ushort? year)
    {
        Title = title;
        Author = author;
        Year = year;
    }
    public Book(string title) : this(title, "Unknown", null) { }
    public void ReadCover()
    {
        Console.WriteLine($"{Title}, {Author}, {Year}");
    }
    public void PrintInfo() => ReadCover();
}

namespace Basics.OOP.Classes;
public class Circle(double radius) : Shape("Circle")
{
    public double Radius { get; set; } = radius;
    public override double GetArea()
    {
        return Math.PI * Math.Pow(Radius, 2);
    }
}

namespace Basics.OOP.Classes;
public class Customer(string name, string email, Address address) : User(name, email)
{
    public Address Address { get; set; } = address;
    public override void PrintInfo()
    {
        base.PrintInfo();
        Address.PrintInfo();
    }
}

using Basics.OOP.Interfaces;
using Basics.OOP.Exceptions;
namespace Basics.OOP.Classes;
public class Library : ILibrarySearchable, IPrintable, ILibraryOperatable
{
    public Dictionary<string, List<Book>> Books { get; set; } = []; //Author: List<Book>
    public Library() { }
    public Library(Dictionary<string, List<Book>> books) => Books = books;
    public Library(List<Book> books) : this(
        books
            .GroupBy(b => b.Author)
            .ToDictionary(g => g.Key, g => g.ToList())
    ) { }
    public void AddBook(Book book)
    {
        if (Books.TryGetValue(book.Author, out List<Book>? value))
        {
            value.Add(book);
        }
        else
        {
            Books.Add(book.Author, [book]);
        }
    }
    public void RemoveBook(string author, string title)
    {
        Books[author].RemoveAll(b => b.Title != title);
    }
    public void RemoveAllBooksByAuthor(string author)
    {
        if (Books.TryGetValue(author, out List<Book>? books))
        {
            Books.Remove(author);
        }
        else
        {
            throw new AuthorNotFoundException($"Books with author \"{author}\" not found");
        }
    }
    public void RemoveAllBooksWithTitle(string title)
    {
        var containFlag = false;
        foreach (var pair in Books)
        {
            if (pair.Value.Any(b => b.Title == title))
            {
                pair.Value.RemoveAll(b => b.Title == title);
                containFlag = true;
            }
        }
        if (!containFlag)
        {
            throw new TitleNotFoundException($"Books with title \"{title}\" not found");
        }
    }
    public IEnumerable<Book> FindAllBooksByTitle(string title)
    {
        return Books
            .Values
            .SelectMany(list => list)
            .Where(b => b.Title == title);
    }
    public IEnumerable<Book> FindAllBooksByAuthor(string author)
    {
        return Books[author];
    }
    public IEnumerable<Book> FindAllBooksByYear(ushort? year)
    {
        return Books
            .Values
            .SelectMany(list => list)
            .Where(b => b.Year == year);
    }
    public Book? FindBook(string title, string author, ushort? year)
    {
        return Books[author]
            .FirstOrDefault(b => 
                b.Title == title && 
                b.Year == year
            );
    }
    public List<Book> Filter(Func<Book, bool> filter)
    {
        return Books.Values.SelectMany(list => list).Where(filter).ToList();
    }
    public void PrintInfo()
    {
        foreach (var pair in Books)
        {
            Console.WriteLine(pair.Key);
            foreach (var book in pair.Value)
            {
                Console.WriteLine($" - \"{book.Title}\", {book.Year}");
            }
        }
    }
}

using Basics.OOP.Interfaces;
using System.Globalization;

namespace Basics.OOP.Classes;

public class Order(Customer customer, Dictionary<Product, ushort>? products, DateOnly date) : IPrintable, IOrderExportable, IOrderOperatable
{
    public Order(Customer customer, List<Product> products, DateOnly date)
    : this(customer,
        products.GroupBy(p => p).ToDictionary(g => g.Key, g => (ushort)g.Count()),
        date
    ) { }
    public Customer Customer { get; set; } = customer;
    public Dictionary<Product, ushort> Products { get; set; } = products ?? [];
    public DateOnly Date { get; set; } = date;
    public decimal GetTotalPrice() => Products.Sum(pair => pair.Key.Price * pair.Value);
    public void AddProduct(Product product)
    {
        if (Products.TryGetValue(product, out ushort value))
        {
            Products[product] = ++value;
        }
        else
        {
            Products.Add(product, 0);
        }
    }
    public int GetUniqueCount() => Products.Keys.Count;
    public void PrintInfo(TextWriter writer)
    {
        CultureInfo.CurrentCulture = CultureInfo.InvariantCulture;
        writer.WriteLine($"Customer: {Customer.Name}");
        foreach (var product in Products)
        {
            var total_price = product.Key.Price * product.Value;
            writer.WriteLine(
                $" - {product.Key.Name} x {product.Value}: {total_price}$"
            );
        }
        writer.WriteLine($"Total: {GetTotalPrice()}$");
    }
    public void PrintInfo() => PrintInfo(Console.Out);
    public void ExportToText(string path = "../../../OOP/Data/OrderWrite/Order.txt")
    {
        using var sw = new StreamWriter(path);
        PrintInfo(sw);
    }
}
using Basics.OOP.Interfaces;
namespace Basics.OOP.Classes;
public class Person(string name, ushort age) : IPresentable, IPrintable
{
    public string Name { get; set; } = name;
    public ushort Age { get; set; } = age;
    public virtual void Introduce()
    {
        Console.WriteLine($"My name is {Name}, I am {Age} years old");
    }
    public void PrintInfo() => Introduce();
}

using Basics.OOP.Interfaces;
namespace Basics.OOP.Classes;
public readonly record struct Product(string name, decimal price) : IPurchasable, IOrderable, IPrintable
{
    public string Name { get; } = name;
    public decimal Price { get; } = price;
    public void PrintInfo()
    {
        Console.WriteLine($"Name: {Name}, Price: {Price}");
    }
}
namespace Basics.OOP.Classes;
public class Rectangle(double width, double height) : Shape("Rectangle")
{
    public double Width { get; set; } = width;
    public double Height { get; set; } = height;
    public override double GetArea()
    {
        return Width * Height;
    }
}

using Basics.OOP.Interfaces;
namespace Basics.OOP.Classes;
public abstract class Shape(string name) : IAreaComputable, IPrintable
{
    public string Name { get; set; } = name;
    public abstract double GetArea();
    public void PrintInfo()
    {
        Console.WriteLine($"{Name}: {GetArea()}");
    }
}

using Basics.OOP.Interfaces;
namespace Basics.OOP.Classes;
public class Store(List<Product>? products, Queue<Order>? orders) : IStore, IPrintable, IStoreSearchable
{
    public List<Product> Catalogue { get; set; } = products ?? [];
    public Queue<Order> Orders { get; set; } = orders ?? [];
    public void AddProduct(Product product)
    {
        Catalogue.Add(product);
    }
    public void PlaceOrder(Order order)
    {
        Orders.Enqueue(order);
    }
    public void PlaceOrders(List<Order> orders)
    {
        orders.ForEach(o => PlaceOrder(o));
    }
    public Order ProcessOrder()
    {
        return Orders.Dequeue();
    }
    public IEnumerable<Order> GetOrdersByCustomer(string customerName)
    {
        return Orders.Where(o => o.Customer.Name == customerName);
    }
    public IEnumerable<Product> GetProductsCheaperThan(decimal maxPrice)
    {
        return Catalogue.Where(c => c.Price <= maxPrice);
    }
    public void PrintInfo()
    {
        foreach (var product in Catalogue)
        {
            product.PrintInfo();
        }
        foreach (var order in Orders)
        {
            order.PrintInfo();
        }
    }
    public void PrintAllOrders()
    {
        Orders.ToList().ForEach(o => o.PrintInfo());
    }
}
namespace Basics.OOP.Classes;
public class Student(string group, string name, ushort age) : Person(name, age)
{
    public string Group { get; set; } = group;
    public override void Introduce()
    {
        Console.Write($"I am a student of a group {Group}, ");
        base.Introduce();
    }
}

namespace Basics.OOP.Classes;
public class Teacher(string subject, string name, ushort age) : Person(name, age)
{
    public string Subject { get; set; } = subject;
    public override void Introduce()
    {
        Console.Write($"I am a {Subject} teacher, ");
        base.Introduce();
    }
}
using Basics.OOP.Interfaces;

namespace Basics.OOP.Classes;

public class User(string name, string email) : IUserInfo, IPrintable
{
    public string Name { get; set; } = name;
    public string Email { get; set; } = email;
    public virtual void PrintInfo()
    {
        Console.WriteLine($"Name: {Name}, Email: {Email}");
    }
}
namespace Basics.OOP.Exceptions;

public class AuthorNotFoundException : Exception
{
    public AuthorNotFoundException() { }
    public AuthorNotFoundException(string message) : base(message) { }
    public AuthorNotFoundException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.OOP.Exceptions;

public class LibraryLoadingException : Exception
{
    public LibraryLoadingException() { }
    public LibraryLoadingException(string message) : base(message) { }
    public LibraryLoadingException(string message, Exception innerException) : base(message, innerException) { }
}
namespace Basics.OOP.Exceptions;

public class LibrarySavingException : Exception
{
    public LibrarySavingException() { }
    public LibrarySavingException(string message) : base(message) { }
    public LibrarySavingException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.OOP.Exceptions;

public class TitleNotFoundException : Exception
{
    public TitleNotFoundException() { }
    public TitleNotFoundException(string message) : base(message) { }
    public TitleNotFoundException(string message, Exception innerException) : base(message, innerException) { }
}

namespace Basics.OOP.Interfaces;
public interface IAreaComputable
{
    public double GetArea();
}
namespace Basics.OOP.Interfaces;
public interface IUserInfo
{
    public string Name { get; set; }
    public string Email { get; set; }
}
using Basics.OOP.Classes;
namespace Basics.OOP.Interfaces;
public interface ILibraryOperatable
{
    public void AddBook(Book book);
    public void RemoveBook(string author, string title);
    public void RemoveAllBooksByAuthor(string author);
    public void RemoveAllBooksWithTitle(string title);
}

using Basics.OOP.Classes;

namespace Basics.OOP.Interfaces;
public interface ILibrarySearchable
{
    IEnumerable<Book> FindAllBooksByTitle(string title);
    IEnumerable<Book> FindAllBooksByAuthor(string author);
    IEnumerable<Book> FindAllBooksByYear(ushort? year);
    Book? FindBook(string title, string author, ushort? year);
}

namespace Basics.OOP.Interfaces;

public interface IOrderable { }
namespace Basics.OOP.Interfaces;

public interface IOrderExportable
{
    public void ExportToText(string path);
}

using Basics.OOP.Classes;

namespace Basics.OOP.Interfaces;

public interface IOrderOperatable
{
    public void AddProduct(Product product);
}
namespace Basics.OOP.Interfaces;
public interface IPresentable
{
    public void Introduce();
}
namespace Basics.OOP.Interfaces;
public interface IPrintable
{
    public void PrintInfo();
}
namespace Basics.OOP.Interfaces;

public interface IPurchasable
{
    public string Name { get; }
    public decimal Price { get; }
}

namespace Basics.OOP.Interfaces;
public interface IReadable
{
    public void ReadCover();
}

using Basics.OOP.Classes;

namespace Basics.OOP.Interfaces;

public interface IStore
{
    public void AddProduct(Product product);
    public void PlaceOrder(Order order);
    public Order ProcessOrder();
}
using Basics.OOP.Classes;

namespace Basics.OOP.Interfaces;
public interface IStoreSearchable
{
    public IEnumerable<Order> GetOrdersByCustomer(string customerId);
    public IEnumerable<Product> GetProductsCheaperThan(decimal maxPrice);
}
using Basics.OOP.Classes;
using System.Text.Json;
using Basics.OOP.Exceptions;
namespace Basics.OOP.Services;
public static class LibraryHandler
{
    public static async Task SaveToFileAsync(this Library library, string path = "../../../OOP/Data/LibraryWrite/Library.json")
    {
        try
        {
            await using var fs = File.Create(path);
            await JsonSerializer.SerializeAsync(fs, library);
        }
        catch (Exception e)
        {
            throw new LibrarySavingException(e.Message);
        }
    }
    public static void SaveToFile(this Library library, string path = "../../../OOP/Data/LibraryWrite/Library.json")
    {
        try
        {
            using var fs = File.Create(path);
            JsonSerializer.SerializeAsync(fs, library);
        }
        catch (Exception e)
        {
            throw new LibrarySavingException(e.Message);
        }
    }
    public static async Task<Library?> LoadFromFileAsync(string path = "../../../OOP/Data/LibraryRead/Library.json")
    {
        try
        {
            await using var fs = File.OpenRead(path);
            return await JsonSerializer.DeserializeAsync<Library>(fs);
        }
        catch (Exception e)
        {
            throw new LibraryLoadingException(e.Message);
        }
    }
    public static Library? LoadFromFile(string path = "../../../OOP/Data/LibraryRead/Library.json")
    {
        try
        {
            using var fs = File.OpenRead(path);
            return JsonSerializer.Deserialize<Library>(fs);
        }
        catch (Exception e)
        {
            throw new LibraryLoadingException(e.Message);
        }
    }
}
using Basics.OOP.Interfaces;

namespace Basics.OOP.Services;

public static class PersonHandler
{
    public static void IntroduceAll(this List<IPresentable> presentables)
    {
        foreach (var presentable in presentables)
        {
            presentable.Introduce();
        }
    }
}
using Basics.OOP.Interfaces;
namespace Basics.OOP.Services;
public static class PrintHandler
{
    public delegate void PrintDelegate(IPrintable printable);
    public static void PrintAll(this List<IPrintable> printables, PrintDelegate printer)
    {
        foreach (var printable in printables)
        {
            printer(printable);
        }
    }
}
using Basics.OOP.Classes;

namespace Basics.OOP.Services;

public static class ShapeHandler
{
    public static void PrintAllAreas(List<Shape> shapes)
    {
        foreach (var shape in shapes)
        {
            Console.WriteLine(shape.GetArea());
        }
    }
}
